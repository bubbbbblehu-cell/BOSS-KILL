# BOSS KILL 小游戏前端服务功能设计

## 项目概述
这是一个基于React Native + Node.js的在线小游戏前端应用，主要功能包括用户登录、地图展示、滑一滑推荐、绘图模块、推荐系统等。采用混合数据同步策略：实时数据通过Firebase实现同步，复杂业务逻辑通过Node.js API处理。

## 核心功能模块

### 1. 用户认证服务 (AuthService)

#### 功能描述
处理用户邮箱注册、登录、登出以及匿名登陆（游客模式）、密码重置等认证相关功能

#### 功能需要API接口的功能
- 需要API接口的操作包括：`signInWithEmailPassword`、`signUpWithEmailPassword`、`signInAnonymously`、`resetPassword`、`signOut`，以及用户登录日志的记录（_recordLoginLog）。
- 这些操作通常涉及服务端校验、数据库存储、Token生成、状态更新等，必须与后端/数据库进行交互，前端需通过HTTP请求（RESTful或GraphQL等API）调用相关接口。
- `getCurrentUser()` 和 `authStateChanges()` 通常是结合本地Session管理实现（如使用JWT、Firebase等），如果需要实时校验Session有效性，也可能涉及API请求。

#### 详细说明
```dart
class AuthService {
  // 用户登录：需要API。服务端鉴权、数据库查验，生成Token，记录登录日志
  Future<User?> signInWithEmailPassword(String email, String password, {String? loginIp}) async {
    // 1. 校验邮箱和密码，并与用户数据进行比对
    // 2. 若匹配成功，记录以下信息：
    //    - 用户ID
    //    - 加密后的密码
    //    - 本次登录时间
    //    - 登录IP（服务端提供）
    //    - 设备信息（如设备型号、操作系统版本、App版本等，便于安全分析与兼容性追踪）
    //    - 登录地理位置（如可获取，提升安全与风险识别能力）
    //    - 登录方式（邮箱/游客/第三方等）
    //    - 登录渠道（如iOS/Android/Web端等）
    //    - 首次登录标识或统计字段（如为新用户）
    //    - 登录状态（正常/异常/风险等，便于风控处理）
    //    - 附加安全验证信息（如多因素认证标记、验证码通过状态）
    // 3. 可实现为：保存到本地日志或远程数据库
    // 4. 返回当前用户信息User
  }
  
  // 用户注册：API调用，注册新用户
  Future<User?> signUpWithEmailPassword(String email, String password)
    // 需要调用API接口：/auth/register
    // 前端提交注册数据到服务端，服务端校验后创建新用户并返回User信息

  // 匿名登录（游客模式）
  Future<User?> signInAnonymously()
    // 需要调用API接口：/auth/anonymous
    // 服务端生成匿名用户映射，并返回游客User信息

  // 密码重置：API调用，触发重置流程（如发送邮件）
  Future<void> resetPassword(String email)
    // 需要调用API接口：/auth/reset-password
    // 服务端处理密码重置流程（如生成token、发送邮件、更新数据库）

  // 登出：通常需要API调用以注销Session（如清理Token/黑名单处理）
  Future<void> signOut()
    // 可选调用API接口：/auth/logout
    // 前端清除本地状态，服务端可作Session黑名单等处理

  // 获取当前用户：前端本地获取，或通过API校验Token有效性
  User? getCurrentUser()
    // 通常从本地缓存获取，如需准实时校验可访问API：/auth/current

  // 监听认证状态变化：本地状态流（如基于Token变化监听），如需服务器push需配合WebSocket等
  Stream<User?> authStateChanges()

  // 记录详细的登录日志（内部辅助方法）—— 通常由服务端在处理登录API时自动记录
  Future<void> _recordLoginLog(String userId, String status, Map<String, dynamic> metadata)
    // 若需前端自定义补充数据，也需API接口：/auth/login-log
}
```


#### 数据库设计支持
> 详细表结构见 `用户认证数据库初始化.sql`

1. **用户表 (users)**：存储邮箱、加密密码、用户类型等
2. **登录日志表 (user_login_logs)**：记录IP、设备、地理位置、风险等级等
3. **匿名映射表 (anonymous_user_mapping)**：支持游客转正
4. **密码重置表 (password_reset_tokens)**：安全的密码找回机制

#### 登录数据记录项
- **基础信息**：用户ID、加密密码（哈希）、登录时间
- **环境信息**：IP地址、设备型号、OS版本、App版本
- **安全信息**：地理位置、登录渠道、风险状态
- **行为信息**：首次登录标记、登录方式

#### UI集成点
- 登录页面：邮箱密码登录表单
- 注册页面：用户注册表单
- 密码重置页面：邮箱输入表单
- 游客模式入口

### 2. 登录演示服务 (LoginDemoService)

#### 功能描述
在用户登录时，展示动画演示：shit的第一视角动画、被辱骂场景、扔大便的动画效果

#### 功能模块分类

| 功能 | 是否需要API | 数据来源 |
|------|------------|----------|
| 动画演示（老板、shit视角） | ❌ 不需要 | 本地Lottie/视频资源 |
| 隐私声明 | ❌ 不需要 | 本地静态文字 |
| **激励文字** | ✅ **需要API** | **激励文字数据库** |
| 跳过演示 | ❌ 不需要 | 本地导航逻辑 |

---

### 激励文字数据库调用详解

#### API接口：`/api/quotes/random`

#### 调用步骤

```
┌─────────────────────────────────────────────────────────────────────┐
│  前端调用流程                                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 前端调用 showMotivationalText()                                  │
│           ↓                                                         │
│  2. 发送 HTTP GET 请求到 /api/quotes/random                          │
│           ↓                                                         │
│  3. Node.js API 服务接收请求                                          │
│           ↓                                                         │
│  4. 执行数据库存储过程 get_random_motivational_quote()                 │
│           ↓                                                         │
│  5. 数据库返回随机激励文字数据                                          │
│           ↓                                                         │
│  6. API 返回 JSON 响应给前端                                          │
│           ↓                                                         │
│  7. 前端展示激励文字                                                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 详细步骤说明

**步骤1：前端发起请求**
```dart
// LoginDemoService 中调用
Future<String> showMotivationalText() async {
  return await _quotesService.getRandomQuote();
}
```

**步骤2：MotivationalQuotesService 发送HTTP请求**
```dart
class MotivationalQuotesService {
  final Dio _apiClient;

  MotivationalQuotesService(this._apiClient);

  /// 从数据库获取随机激励文字
  /// API接口: GET /api/quotes/random
  Future<String> getRandomQuote() async {
    try {
      final response = await _apiClient.get('/api/quotes/random');
      if (response.statusCode == 200) {
        final data = response.data;
        return data['text'] as String;
      }
      throw Exception('获取激励文字失败');
    } catch (e) {
      // 网络异常时使用本地备用文字
      return _getLocalFallbackQuote();
    }
  }

  /// 本地备用文字（网络异常时使用）
  String _getLocalFallbackQuote() {
    const fallbackQuotes = [
      '在最好的青春里，在格子间里激励自己开出最美的花！',
      '工作虽苦，但扔大便的快乐谁懂？',
    ];
    fallbackQuotes.shuffle();
    return fallbackQuotes.first;
  }
}
```

**步骤3-4：Node.js API 服务处理请求**
```javascript
// routes/quotes.js
const express = require('express');
const router = express.Router();
const db = require('../db');

// GET /api/quotes/random
router.get('/random', async (req, res) => {
  try {
    // 调用数据库存储过程
    const [rows] = await db.query('CALL get_random_motivational_quote()');
    
    if (rows[0] && rows[0].length > 0) {
      const quote = rows[0][0];
      res.json({
        success: true,
        data: {
          id: quote.id,
          text: quote.text,
          category: quote.category,
          author: quote.author
        }
      });
    } else {
      res.status(404).json({ success: false, message: '没有可用的激励文字' });
    }
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

module.exports = router;
```

**步骤5：数据库存储过程执行**
```sql
-- 激励文字数据库.sql 中定义的存储过程
CALL get_random_motivational_quote();

-- 返回数据示例:
-- +------------+--------------------------------------------------+-----------+--------+
-- | id         | text                                             | category  | author |
-- +------------+--------------------------------------------------+-----------+--------+
-- | quote_001  | 在最好的青春里，在格子间里激励自己开出最美的花！      | motivation| 系统    |
-- +------------+--------------------------------------------------+-----------+--------+
```

**步骤6：API返回JSON响应**
```json
{
  "success": true,
  "data": {
    "id": "quote_001",
    "text": "在最好的青春里，在格子间里激励自己开出最美的花！",
    "category": "motivation",
    "author": "系统"
  }
}
```

**步骤7：前端展示激励文字**
```dart
// 在动画流程中展示
void _showQuoteDialog(BuildContext context, String quoteText) {
  showDialog(
    context: context,
    builder: (_) => AlertDialog(
      content: Text(
        quoteText,
        style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        textAlign: TextAlign.center,
      ),
    ),
  );
}
```

---

### 完整服务实现代码

```dart
class LoginDemoService {
  final MotivationalQuotesService _quotesService;

  LoginDemoService(this._quotesService);

  // 播放老板演示动画（本地资源，无需API）
  Future<void> playBossDemoAnimation(BuildContext context) async {
    await showDialog(
      context: context,
      builder: (_) => Lottie.asset('assets/animations/boss_demo.json'),
    );
  }

  // 显示隐私声明（本地静态文字，无需API）
  void showPrivacyNotice(BuildContext context) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        content: Text('数据只用于游戏存档，请放心'),
      ),
    );
  }

  // 播放shit视角动画（本地资源，无需API）
  Future<void> playShitPerspectiveAnimation(BuildContext context) async {
    await showDialog(
      context: context,
      builder: (_) => Lottie.asset('assets/animations/shit_perspective.json'),
    );
  }

  /// 展示激励文字（需要API调用激励文字数据库）
  /// 调用链：前端 → API(/api/quotes/random) → 数据库(get_random_motivational_quote)
  Future<String> showMotivationalText() async {
    return await _quotesService.getRandomQuote();
  }

  // 跳过演示，直接进入登录页（本地导航，无需API）
  void skipDemo(BuildContext context) {
    Navigator.of(context).popUntil((route) => route.isFirst);
  }
}
```

---

### 动画场景串联流程

```dart
Future<void> runLoginDemoSequence(BuildContext context) async {
  final demoService = ServiceLocator().loginDemoService;

  // 1. 播放老板样本动画（本地资源）
  await demoService.playBossDemoAnimation(context);

  // 2. shit第一视角动画（本地资源）
  await demoService.playShitPerspectiveAnimation(context);

  // 3. 展示激励文字（从数据库获取）
  final quoteText = await demoService.showMotivationalText();
  await _showQuoteWithAnimation(context, quoteText);

  // 4. 最后展示隐私声明（本地静态）
  demoService.showPrivacyNotice(context);
}
```

用户任选时刻可调用 `skipDemo(context)` 跳过所有演示，直达登录。

---

#### 数据库依赖
> 激励文字数据来源：`激励文字数据库.sql`
> - 表：`motivational_quotes`
> - 存储过程：`get_random_motivational_quote()`

#### 动画序列
1. **固定老板样本展示**：展示预设的老板形象（本地Lottie）
2. **shit第一视角动画**：（本地Lottie）
   - 看到别人被辱骂的场景
   - 被拿起来的动作
   - 飞到地图上的抛物线轨迹
3. **扔大便原因说明**：（**API调用激励文字数据库**）
   - 从数据库随机获取激励文字并展示
4. **隐私声明**：一切信息会被保密（本地静态）



### 3. 地图服务 (MapService)

#### 功能描述
处理实时地图显示、大便塔生成、24小时地图更新等功能

#### 功能模块与API/数据库依赖

| 功能 | 是否需要API | 数据库表 | 存储过程 |
|------|------------|----------|----------|
| 获取附近大便分布 | ✅ 需要 | `shit_points` | `api_map_get_nearby_shit_points` |
| 获取全局地图数据 | ✅ 需要 | `map_cache` | `api_map_get_global_data` |
| 添加新的大便点 | ✅ 需要 | `shit_points` | `api_map_add_shit_point` |
| 检查屎塔生成条件 | ✅ 需要 | `shit_points` | `api_map_check_tower_formation` |
| 生成屎塔 | ✅ 需要 | `shit_towers`, `tower_contributors` | `api_map_create_shit_tower` |
| 获取附近屎塔 | ✅ 需要 | `shit_towers`, `buildings` | `api_map_get_nearby_towers` |
| 获取被占领建筑 | ✅ 需要 | `buildings`, `shit_towers` | `api_map_get_occupied_buildings` |
| 实时数据监听 | ✅ Firebase/WebSocket | - | - |

> **数据库依赖**: `地图服务数据库初始化.sql`

---

### 地图服务API调用详解

#### API接口列表

| 接口 | 方法 | 功能 |
|------|------|------|
| `/api/map/shit-points` | GET | 获取附近大便分布 |
| `/api/map/shit-points` | POST | 添加新的大便点 |
| `/api/map/global` | GET | 获取全局地图数据（24小时缓存） |
| `/api/map/towers` | GET | 获取附近屎塔 |
| `/api/map/towers` | POST | 生成屎塔 |
| `/api/map/buildings/occupied` | GET | 获取被占领建筑 |

#### 调用流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│  地图数据加载流程                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 前端获取用户位置 (GPS)                                            │
│           ↓                                                         │
│  2. 调用 getNearbyShitPoints() → GET /api/map/shit-points           │
│           ↓                                                         │
│  3. 数据库执行 api_map_get_nearby_shit_points()                      │
│           ↓                                                         │
│  4. 返回大便分布数据，前端渲染地图                                      │
│           ↓                                                         │
│  5. 同时调用 GET /api/map/towers 获取屎塔数据                         │
│           ↓                                                         │
│  6. 前端合并渲染大便点和屎塔                                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  扔大便流程                                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 用户点击扔大便                                                    │
│           ↓                                                         │
│  2. 调用 addShitPoint() → POST /api/map/shit-points                 │
│           ↓                                                         │
│  3. 数据库执行 api_map_add_shit_point()                              │
│           ↓                                                         │
│  4. 检查是否达到屎塔生成阈值 (>= 1000)                                 │
│           ↓                                                         │
│  5a. 未达到：返回成功，前端更新地图                                     │
│  5b. 已达到：自动调用 api_map_create_shit_tower() 生成屎塔             │
│           ↓                                                         │
│  6. 返回结果（含是否生成新屎塔），前端播放动画                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 详细API调用说明

**1. 获取附近大便分布**
```dart
// 前端调用
Future<List<ShitPoint>> getNearbyShitPoints(LatLng center, double radius, String userId) async {
  final response = await api.get('/api/map/shit-points', queryParameters: {
    'latitude': center.latitude,
    'longitude': center.longitude,
    'radius_km': radius,
    'user_id': userId,
  });
  // 数据库执行: CALL api_map_get_nearby_shit_points(lat, lng, radius, userId)
  return (response.data['data'] as List).map((e) => ShitPoint.fromJson(e)).toList();
}
```

**2. 添加新的大便点**
```dart
// 前端调用
Future<AddShitResult> addShitPoint(ShitPoint point) async {
  final response = await api.post('/api/map/shit-points', data: {
    'user_id': point.userId,
    'latitude': point.position.latitude,
    'longitude': point.position.longitude,
    'shit_type': point.type.name,
  });
  // 数据库执行: CALL api_map_add_shit_point(userId, lat, lng, type, @shitId, @towerFormed)
  return AddShitResult(
    shitId: response.data['shit_id'],
    towerFormed: response.data['tower_formed'],
  );
}
```

**3. 获取全局地图数据（24小时缓存）**
```dart
// 前端调用
Future<MapData> getGlobalMapData() async {
  final response = await api.get('/api/map/global');
  // 数据库执行: CALL api_map_get_global_data()
  return MapData.fromJson(response.data);
}
```

**API响应示例**
```json
{
  "success": true,
  "data": {
    "total_shit_points": 15678,
    "total_towers": 23,
    "total_occupied_buildings": 18,
    "top_towers": [
      {
        "id": "tower_001",
        "latitude": 30.2741,
        "longitude": 120.0261,
        "shit_count": 5280,
        "height": 52.8
      }
    ],
    "updated_at": "2025-01-27T06:30:00Z"
  }
}
```

---

#### 核心方法
```dart
class MapService {
  /// 获取用户当前位置的大便分布
  /// - 本人扔出的大便实时同步（如使用Firebase监听或WebSocket）
  /// - 其他用户数据仅每4小时刷新一次（后台定时拉取/缓存）
  Future<List<ShitPoint>> getNearbyShitPoints(
    LatLng center,
    double radius, {
    required String userId,
  }) async {
    

    // 实现“需要实时链接数据库”，通过实时数据库stream真正监听
    final userShit = await realtimeDatabase
        .getUserShitPointsStream(userId, center, radius)
        .first; // 这里first代表拿到最新一帧，可持续监听实现更实时效果

    // 其他用户大便本地有缓存，并每4小时后台自动刷新
    final othersShit = await _getCachedOthersShitPoints(center, radius);

    // 数据合并步骤1：将本人和他人数据合并为一个列表
    final allShitPoints = <ShitPoint>[
      ...userShit,
      ...othersShit,
    ];

    // 数据合并步骤2：去重（假设以id为唯一键），以保证同一个点不会重复
    final mergedShitPoints = {
      for (var shit in allShitPoints) shit.id: shit
    }.values.toList();

   
  /// 获取整体地图数据（24小时更新）
  /// 需要调取地图API接口，建议通过后端API获取最新地图状态（如大便分布、屎塔建筑、热点等）
  Future<MapData> getGlobalMapData() async {
    // 示例：调取后端 API 获取地图数据
    final response = await api.get('/map/global');
    if (response.isSuccessful) {
      return MapData.fromJson(response.data);
    } else {
      throw Exception('Failed to load global map data');
    }
  }

  // 添加新的shit点
  Future<void> addShitPoint(ShitPoint point)

  // 监听地图数据实时变化（需要与后端API或Firebase实时数据库连接）
  Stream<MapData> mapDataChanges() // 需要链接API

  // 检查大便数量是否够成屎塔
  // 规则：当同一个地点被标记大便大于1000次即可生成
  bool shouldFormShitTower(List<ShitPoint> points) {
    // 首先统计每个地点（假设LatLng的精度已经足够，不需要分桶）
    final Map<LatLng, int> countMap = {};
    for (var p in points) {
      countMap[p.position] = (countMap[p.position] ?? 0) + 1;
    }
    // 只要有一个地点累计数量大于等于1000，就可以生成屎塔
    return countMap.values.any((count) => count >= 1000);
  }

  // 生成屎塔数据
  Future<ShitTower> createShitTower(List<ShitPoint> points, LatLng location)

  // 获取屎塔占领的建筑信息
  Future<List<Building>> getOccupiedBuildings()
}
```

#### 数据结构
```dart
class ShitPoint {
  final String id;
  final LatLng position;
  final DateTime timestamp;
  final String userId;
  final ShitType type; // 不同种类的大便
}

class ShitTower {
  final String id;
  final LatLng position;
  final int shitCount;
  final double height;
  final List<String> contributorIds;
  final Building? occupiedBuilding;
}
```

#### UI集成点
- 地图页面：实时显示地图和大便分布
- 便塔可视化：3D或2D屎塔展示，显示被屎塔占领的建筑）



### 4. 滑一滑服务 (SwipeService)

#### 功能描述
处理Top3 banner展示、卡片滑动、点赞收藏等交互功能

#### 功能模块与API/数据库依赖

| 功能 | 是否需要API | 数据库表 | 存储过程 |
|------|------------|----------|----------|
| 获取Top3推荐 | ✅ 需要 | `contents` | `api_swipe_get_top3` |
| 获取推荐内容流 | ✅ 需要 | `contents`, `user_views` | `api_swipe_get_feed` |
| 点赞内容 | ✅ 需要 | `user_likes`, `contents` | `api_swipe_like_content` |
| 取消点赞 | ✅ 需要 | `user_likes`, `contents` | `api_swipe_unlike_content` |
| 收藏内容 | ✅ 需要 | `user_favorites`, `contents` | `api_swipe_favorite_content` |
| 取消收藏 | ✅ 需要 | `user_favorites`, `contents` | `api_swipe_unfavorite_content` |
| 记录浏览 | ✅ 需要 | `user_views`, `contents` | `api_swipe_record_view` |
| 显示弹窗 | ❌ 本地 | - | - |
| 跳转绘图 | ❌ 本地 | - | - |

> **数据库依赖**: `滑一滑服务数据库初始化.sql`

---

### 滑一滑服务API调用详解

#### API接口列表

| 接口 | 方法 | 功能 |
|------|------|------|
| `/api/swipe/top3` | GET | 获取Top3推荐内容 |
| `/api/swipe/feed` | GET | 获取推荐内容流（分页） |
| `/api/swipe/like` | POST | 点赞内容 |
| `/api/swipe/like` | DELETE | 取消点赞 |
| `/api/swipe/favorite` | POST | 收藏内容 |
| `/api/swipe/favorite` | DELETE | 取消收藏 |
| `/api/swipe/view` | POST | 记录浏览 |

#### 调用流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│  首页加载流程                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 打开首页                                                          │
│           ↓                                                         │
│  2. 调用 getTop3Content() → GET /api/swipe/top3                     │
│           ↓                                                         │
│  3. 数据库执行 api_swipe_get_top3() 获取Top3内容                      │
│           ↓                                                         │
│  4. 返回Top3数据，前端渲染Banner                                       │
│           ↓                                                         │
│  5. 同时调用 getContentStream() → GET /api/swipe/feed               │
│           ↓                                                         │
│  6. 数据库执行推荐算法，返回个性化推荐内容                                │
│           ↓                                                         │
│  7. 前端渲染滑动卡片列表                                               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  用户交互流程（点赞/收藏）                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 用户点击点赞/收藏按钮                                               │
│           ↓                                                         │
│  2. 调用 likeContent() → POST /api/swipe/like                       │
│           ↓                                                         │
│  3. 数据库执行 api_swipe_like_content()                              │
│           ↓                                                         │
│  4. 插入点赞记录，更新内容点赞数                                         │
│           ↓                                                         │
│  5. 返回最新点赞数，前端更新UI                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 详细API调用说明

**1. 获取Top3推荐内容**
```dart
// 前端调用
Future<List<ContentItem>> getTop3Content() async {
  final response = await api.get('/api/swipe/top3', queryParameters: {
    'user_id': currentUserId,
  });
  // 数据库执行: CALL api_swipe_get_top3(userId)
  return (response.data['data'] as List).map((e) => ContentItem.fromJson(e)).toList();
}
```

**2. 获取推荐内容流**
```dart
// 前端调用（支持分页）
Future<List<ContentItem>> getContentFeed(int page, int pageSize) async {
  final response = await api.get('/api/swipe/feed', queryParameters: {
    'user_id': currentUserId,
    'page': page,
    'page_size': pageSize,
  });
  // 数据库执行: CALL api_swipe_get_feed(userId, page, pageSize)
  // 推荐算法: score = (like*1.0 + favorite*2.0 + view*0.1) * 时间衰减
  return (response.data['data'] as List).map((e) => ContentItem.fromJson(e)).toList();
}
```

**3. 点赞内容**
```dart
// 前端调用
Future<LikeResult> likeContent(String contentId) async {
  final response = await api.post('/api/swipe/like', data: {
    'user_id': currentUserId,
    'content_id': contentId,
  });
  // 数据库执行: CALL api_swipe_like_content(userId, contentId, @success, @newCount)
  return LikeResult(
    success: response.data['success'],
    newLikeCount: response.data['new_like_count'],
  );
}
```

**API响应示例 - Top3**
```json
{
  "success": true,
  "data": [
    {
      "id": "content_001",
      "image_url": "https://example.com/images/boss1.png",
      "title": "我的老板是秃头",
      "description": "画了一个秃头老板",
      "like_count": 1520,
      "favorite_count": 320,
      "is_liked": false,
      "is_favorited": true,
      "tags": "秃头,搞笑",
      "top_rank": 1
    }
  ]
}
```

#### 推荐算法说明

```sql
-- 推荐分数计算公式
recommendation_score = 
  (like_count * 1.0 + favorite_count * 2.0 + view_count * 0.1) 
  * EXP(-天数差 / 30)

-- 说明：
-- 1. 点赞权重: 1.0
-- 2. 收藏权重: 2.0（收藏比点赞更有价值）
-- 3. 浏览权重: 0.1
-- 4. 时间衰减: 30天半衰期，越新的内容权重越高
```

---

#### 核心方法
```dart
class SwipeService {
  // 获取Top3推荐内容
  Future<List<ContentItem>> getTop3Content()

  // 获取推荐内容流
  Stream<List<ContentItem>> getContentStream()

  // 点赞内容
  Future<void> likeContent(String contentId)

  // 收藏内容
  Future<void> favoriteContent(String contentId)

  // 取消点赞
  Future<void> unlikeContent(String contentId)

  // 取消收藏
  Future<void> unfavoriteContent(String contentId)

  // 显示"你也要画一个吗？"弹窗
  void showDrawingPrompt()

  // 跳转到绘图页面
  void navigateToDrawing(String? referenceContentId)
}
```

#### 数据结构
```dart
class ContentItem {
  final String id;
  final String imageUrl;
  final String title;
  final String description;
  final int likeCount;
  final int favoriteCount;
  final DateTime createdAt;
  final String authorId;
  final List<String> tags;
  final bool isLiked;
  final bool isFavorited;
}
```

#### UI集成点
- 首页Banner：Top3内容横幅展示
- 滑动卡片：支持上下滑动手势
- 交互按钮：点赞、收藏按钮
- 弹窗提示：画图邀请弹窗
- 导航跳转：跳转到绘图模块

### 5. 绘图服务 (DrawingService)

#### 功能描述
处理画笔绘图、贴纸添加、图像审核等功能

#### 核心方法
```dart
class DrawingService {
  // 初始化画布
  Future<void> initializeCanvas(Size size)

  // 添加画笔笔触
  void addBrushStroke(Offset start, Offset end, Color color, double width)

  // 添加贴纸
  Future<void> addSticker(String stickerId, Offset position, double scale, double rotation)

  // 撤销上一步操作
  void undo()

  // 重做上一步操作
  void redo()

  // 清空画布
  void clearCanvas()

  // 保存图像到临时存储
  Future<String> saveTempImage()

  // 上传图像并审核
  Future<UploadResult> uploadAndReviewImage(String tempImagePath, List<String> tags)

  // 生成图像编号
  String generateImageCode()

  // 获取可用贴纸列表
  Future<List<Sticker>> getAvailableStickers()
}
```

#### 数据结构
```dart
class UploadResult {
  final bool success;
  final String? imageId;
  final String? imageUrl;
  final ReviewStatus status;
  final String? rejectionReason;
}

enum ReviewStatus {
  pending,    // 审核中
  approved,   // 通过
  rejected,   // 拒绝
  flagged     // 标记需要人工审核
}

class Sticker {
  final String id;
  final String imageUrl;
  final String name;
  final StickerCategory category;
}
```

#### UI集成点
- 绘图页面：画布、工具栏、颜色选择器
- 贴纸选择器：分类展示可用贴纸
- 审核状态显示：上传进度和审核结果
- 图像预览：绘制完成的图像预览

#### 功能模块与API/数据库依赖

| 功能 | 是否需要API | 数据库表 | 存储过程 |
|------|------------|----------|----------|
| 初始化画布/画笔/撤销/清空 | ❌ 本地 | - | - |
| 获取贴纸分类 | ✅ 需要 | `sticker_categories`, `stickers` | `api_sticker_get_categories` |
| 获取贴纸列表 | ✅ 需要 | `stickers`, `user_stickers` | `api_sticker_get_list` |
| 解锁贴纸 | ✅ 需要 | `user_stickers`, `user_points` | `api_sticker_unlock` |
| 保存绘画作品 | ✅ 需要 | `drawings`, `drawing_stickers` | `api_drawing_save` |
| 提交作品审核 | ✅ 需要 | `drawings`, `drawing_reviews` | `api_drawing_submit_review` |
| 获取作品列表 | ✅ 需要 | `drawings`, `drawing_tags` | `api_drawing_get_by_user` |
| 获取作品详情 | ✅ 需要 | `drawings`, `drawing_tags`, `drawing_stickers` | `api_drawing_get_detail` |
| 获取标签列表 | ✅ 需要 | `tag_definitions` | `api_tag_get_list` |
| 为作品添加标签 | ✅ 需要 | `drawing_tags` | `api_drawing_add_tags` |

> **数据库依赖**: `绘图服务数据库初始化.sql`

---

### 绘图服务API调用详解

#### API接口列表

| 接口 | 方法 | 说明 |
|------|------|------|
| `/api/drawings` | POST | 保存绘画作品 |
| `/api/drawings/:id` | GET | 获取作品详情 |
| `/api/drawings/:id/submit` | POST | 提交作品审核 |
| `/api/drawings/:id/tags` | POST | 为作品添加标签 |
| `/api/drawings/user/:userId` | GET | 获取用户作品列表 |
| `/api/stickers/categories` | GET | 获取贴纸分类 |
| `/api/stickers` | GET | 获取贴纸列表 |
| `/api/stickers/unlock` | POST | 解锁贴纸 |
| `/api/tags` | GET | 获取标签列表 |

#### 1. 贴纸相关API调用

```dart
// 获取贴纸分类
Future<List<StickerCategory>> getStickerCategories() async {
  // GET /api/stickers/categories
  // 返回: { categories: [{ id, name, display_name, sticker_count, icon, color }] }
  final response = await http.get('/api/stickers/categories');
  return response.data['categories'].map((c) => StickerCategory.fromJson(c)).toList();
}

// 获取贴纸列表（含用户解锁状态）
Future<List<Sticker>> getAvailableStickers({String? categoryId}) async {
  // GET /api/stickers?user_id=xxx&category_id=xxx
  // 返回: { stickers: [{ id, name, image_url, is_premium, unlock_type, unlock_value, is_unlocked }] }
  final response = await http.get('/api/stickers', params: {
    'user_id': currentUserId,
    'category_id': categoryId,
  });
  return response.data['stickers'].map((s) => Sticker.fromJson(s)).toList();
}

// 解锁贴纸
Future<UnlockResult> unlockSticker(String stickerId) async {
  // POST /api/stickers/unlock
  // Body: { user_id, sticker_id }
  // 返回: { success, message }
  final response = await http.post('/api/stickers/unlock', data: {
    'user_id': currentUserId,
    'sticker_id': stickerId,
  });
  return UnlockResult(
    success: response.data['success'],
    message: response.data['message'],
  );
}
```

#### 2. 绘画作品API调用

```dart
// 保存绘画作品（草稿或完成）
Future<SaveResult> saveDrawing({
  String? title,
  String? description,
  required Uint8List imageData,
  Map<String, dynamic>? canvasData,
  int? width,
  int? height,
}) async {
  // POST /api/drawings (multipart/form-data)
  // Body: { user_id, title, description, image (file), canvas_data, width, height }
  // 返回: { success, drawing_id, image_code, image_url, thumbnail_url }
  final formData = FormData.fromMap({
    'user_id': currentUserId,
    'title': title,
    'description': description,
    'image': MultipartFile.fromBytes(imageData, filename: 'drawing.png'),
    'canvas_data': jsonEncode(canvasData),
    'canvas_width': width,
    'canvas_height': height,
  });
  final response = await http.post('/api/drawings', data: formData);
  return SaveResult.fromJson(response.data);
}

// 提交作品审核
Future<UploadResult> uploadAndReviewImage(String drawingId, List<String> tags) async {
  // POST /api/drawings/:id/submit
  // Body: { user_id }
  // 返回: { success, review_status, message }
  
  // 先添加标签
  if (tags.isNotEmpty) {
    await http.post('/api/drawings/$drawingId/tags', data: {
      'tags': tags,
    });
  }
  
  // 提交审核
  final response = await http.post('/api/drawings/$drawingId/submit', data: {
    'user_id': currentUserId,
  });
  
  return UploadResult(
    success: response.data['success'],
    imageId: drawingId,
    status: ReviewStatus.values.byName(response.data['review_status']),
  );
}

// 获取用户的绘画作品
Future<List<Drawing>> getMyDrawings({bool includePrivate = true, int page = 1}) async {
  // GET /api/drawings/user/:userId?include_private=true&page=1&page_size=20
  // 返回: { drawings: [{ id, image_code, image_url, title, review_status, like_count, tags, ... }] }
  final response = await http.get('/api/drawings/user/$currentUserId', params: {
    'include_private': includePrivate,
    'page': page,
    'page_size': 20,
  });
  return response.data['drawings'].map((d) => Drawing.fromJson(d)).toList();
}

// 获取作品详情
Future<DrawingDetail> getDrawingDetail(String drawingId) async {
  // GET /api/drawings/:id?viewer_id=xxx
  // 返回: { drawing: {...}, stickers: [...] }
  final response = await http.get('/api/drawings/$drawingId', params: {
    'viewer_id': currentUserId,
  });
  return DrawingDetail.fromJson(response.data);
}
```

#### 3. 标签相关API调用

```dart
// 获取标签列表
Future<List<TagDefinition>> getTagList({String? category}) async {
  // GET /api/tags?category=boss_type
  // 返回: { tags: [{ id, name, display_name, category, color, usage_count }] }
  final response = await http.get('/api/tags', params: {
    'category': category,
  });
  return response.data['tags'].map((t) => TagDefinition.fromJson(t)).toList();
}

// 为作品添加标签
Future<void> addTagsToDrawing(String drawingId, List<String> tags) async {
  // POST /api/drawings/:id/tags
  // Body: { tags: ["tag1", "tag2"] }
  await http.post('/api/drawings/$drawingId/tags', data: {
    'tags': tags,
  });
}
```

#### 数据结构定义

```dart
class StickerCategory {
  final String id;
  final String name;
  final String displayName;
  final String? icon;
  final String? color;
  final int stickerCount;
}

class Sticker {
  final String id;
  final String name;
  final String imageUrl;
  final String? thumbnailUrl;
  final bool isPremium;
  final String unlockType;  // free, points, vip, achievement
  final int unlockValue;
  final bool isUnlocked;
  final String categoryName;
}

class UnlockResult {
  final bool success;
  final String message;
}

class SaveResult {
  final bool success;
  final String? drawingId;
  final String? imageCode;
  final String? imageUrl;
  final String? thumbnailUrl;
}

class Drawing {
  final String id;
  final String imageCode;
  final String imageUrl;
  final String? thumbnailUrl;
  final String? title;
  final String? description;
  final ReviewStatus reviewStatus;
  final int likeCount;
  final int viewCount;
  final bool isPublic;
  final DateTime createdAt;
  final List<String> tags;
}

class DrawingDetail extends Drawing {
  final String userId;
  final int? canvasWidth;
  final int? canvasHeight;
  final int shareCount;
  final DateTime? publishedAt;
  final List<DrawingSticker> stickers;
}

class DrawingSticker {
  final String stickerId;
  final String stickerName;
  final String stickerImage;
  final double positionX;
  final double positionY;
  final double scale;
  final double rotation;
}

class TagDefinition {
  final String id;
  final String name;
  final String displayName;
  final String category;
  final String? color;
  final String? icon;
  final int usageCount;
}
```

#### 绘图流程

```
┌─────────────────────────────────────────────────────────────┐
│                      用户绘图流程                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐ │
│  │ 初始化  │───▶│  绘画   │───▶│  保存   │───▶│  审核   │ │
│  │  画布   │    │  操作   │    │  草稿   │    │  提交   │ │
│  └─────────┘    └─────────┘    └─────────┘    └─────────┘ │
│       │              │              │              │        │
│       ▼              ▼              ▼              ▼        │
│   本地操作        本地操作     ┌─────────┐    ┌─────────┐ │
│                              │  API    │    │  API    │ │
│   获取贴纸       画笔/贴纸    │ 保存    │    │ 提交    │ │
│   (API调用)      撤销/重做    │ 作品    │    │ 审核    │ │
│       │                      └─────────┘    └─────────┘ │
│       ▼                            │              │        │
│  ┌─────────┐                      ▼              ▼        │
│  │ 贴纸    │                 生成编号       AI自动审核    │
│  │ 分类    │                 BOSS2026       + 人工审核    │
│  │ 列表    │                 0127001                      │
│  └─────────┘                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6. 推荐服务 (RecommendationService)

#### 功能描述
处理上下滑动卡片推荐、用户互动、积分系统等功能

#### 功能模块与API/数据库依赖

| 功能 | 是否需要API | 数据库表 | 存储过程 |
|------|------------|----------|----------|
| 获取推荐内容流 | ✅ 需要 | `contents`, `user_actions` | 复用滑一滑服务 |
| 关注用户 | ✅ 需要 | `user_follows` | `api_social_follow_user` |
| 取消关注 | ✅ 需要 | `user_follows` | `api_social_unfollow_user` |
| 加好友 | ✅ 需要 | `user_friends` | `api_social_add_friend` |
| 发送礼物 | ✅ 需要 | `gifts`, `gift_records`, `user_points` | `api_gift_send` |
| 记录用户行为 | ✅ 需要 | `user_actions`, `point_transactions` | `api_action_record` |
| 获取用户积分 | ✅ 需要 | `user_points` | `api_points_get` |
| 获取解锁奖励 | ✅ 需要 | `rewards`, `user_rewards` | `api_rewards_get_unlocked` |
| 获取打卡进度 | ✅ 需要 | `check_in_stats`, `check_in_records` | `api_checkin_get_progress` |
| 打卡 | ✅ 需要 | `check_in_records`, `check_in_stats`, `user_points` | `api_checkin` |
| 获取打卡榜 | ✅ 需要 | `check_in_stats` | `api_checkin_leaderboard` |

> **数据库依赖**: `推荐服务数据库初始化.sql`

---

### 推荐服务API调用详解

#### API接口列表

| 接口 | 方法 | 功能 |
|------|------|------|
| `/api/social/follow` | POST | 关注用户 |
| `/api/social/follow` | DELETE | 取消关注 |
| `/api/social/friend/request` | POST | 发送好友请求 |
| `/api/social/friend/accept` | PUT | 接受好友请求 |
| `/api/gift/send` | POST | 发送礼物 |
| `/api/action/record` | POST | 记录用户行为 |
| `/api/points` | GET | 获取用户积分 |
| `/api/checkin` | POST | 打卡 |
| `/api/checkin/progress` | GET | 获取打卡进度 |
| `/api/checkin/leaderboard` | GET | 获取打卡排行榜 |
| `/api/rewards` | GET | 获取所有奖励 |
| `/api/rewards/unlock` | POST | 解锁奖励 |
| `/api/rewards/unlocked` | GET | 获取已解锁奖励 |

#### 调用流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│  社交交互流程（关注/好友）                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 用户点击"关注"按钮                                                │
│           ↓                                                         │
│  2. 调用 followUser() → POST /api/social/follow                     │
│           ↓                                                         │
│  3. 数据库执行 api_social_follow_user()                              │
│           ↓                                                         │
│  4. 插入关注记录到 user_follows 表                                    │
│           ↓                                                         │
│  5. 返回成功，前端更新关注状态UI                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  打卡流程                                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 用户点击"打卡"按钮                                                │
│           ↓                                                         │
│  2. 调用 checkIn() → POST /api/checkin                              │
│           ↓                                                         │
│  3. 数据库执行 api_checkin()                                         │
│           ↓                                                         │
│  4. 检查是否已打卡、计算连续天数、计算积分奖励                            │
│           ↓                                                         │
│  5. 返回: { streak: 7, points_earned: 24, message: "连续7天!" }      │
│           ↓                                                         │
│  6. 前端播放打卡动画，更新积分显示                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  礼物发送流程                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 用户选择礼物并点击发送                                              │
│           ↓                                                         │
│  2. 调用 sendGift() → POST /api/gift/send                           │
│           ↓                                                         │
│  3. 数据库执行 api_gift_send()                                       │
│           ↓                                                         │
│  4. 检查积分是否足够 → 扣除积分 → 记录礼物发送                            │
│           ↓                                                         │
│  5. 返回成功，前端播放礼物特效                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 详细API调用说明

**1. 关注用户**
```dart
Future<bool> followUser(String targetUserId) async {
  final response = await api.post('/api/social/follow', data: {
    'follower_id': currentUserId,
    'following_id': targetUserId,
  });
  // 数据库执行: CALL api_social_follow_user(currentUserId, targetUserId, @success)
  return response.data['success'];
}
```

**2. 打卡**
```dart
Future<CheckInResult> checkIn() async {
  final response = await api.post('/api/checkin', data: {
    'user_id': currentUserId,
  });
  // 数据库执行: CALL api_checkin(userId, @success, @streak, @points, @message)
  // 积分计算: 基础10分 + 连续天数奖励(最多+20分)
  return CheckInResult(
    success: response.data['success'],
    streak: response.data['streak'],
    pointsEarned: response.data['points_earned'],
    message: response.data['message'],
  );
}
```

**3. 发送礼物**
```dart
Future<GiftResult> sendGift(String receiverId, String giftId, {String? message}) async {
  final response = await api.post('/api/gift/send', data: {
    'sender_id': currentUserId,
    'receiver_id': receiverId,
    'gift_id': giftId,
    'message': message,
  });
  // 数据库执行: CALL api_gift_send(senderId, receiverId, giftId, contentId, message, @success, @error)
  return GiftResult.fromJson(response.data);
}
```

**API响应示例 - 打卡**
```json
{
  "success": true,
  "streak": 7,
  "points_earned": 22,
  "message": "打卡成功！连续7天"
}
```

**API响应示例 - 打卡排行榜**
```json
{
  "success": true,
  "data": [
    { "user_id": "user_002", "current_streak": 12, "total_check_ins": 38, "rank": 1 },
    { "user_id": "user_001", "current_streak": 7, "total_check_ins": 45, "rank": 2 },
    { "user_id": "user_003", "current_streak": 3, "total_check_ins": 22, "rank": 3 }
  ]
}
```

#### 积分规则说明

| 行为 | 积分 | 每日上限 |
|------|------|----------|
| 浏览内容 | +1 | 10次 |
| 点赞内容 | +2 | 50次 |
| 评论内容 | +5 | 50次 |
| 收藏内容 | +3 | 20次 |
| 分享内容 | +10 | 10次 |
| 每日打卡 | +10~30 | 1次 |

**打卡积分计算公式：**
```
打卡积分 = 基础积分(10) + MIN(连续天数-1, 10) × 2
```
示例：连续打卡7天 = 10 + 6×2 = 22分

---

#### 核心方法
```dart
class RecommendationService {
  // 获取推荐内容流
  Stream<List<RecommendedItem>> getRecommendationStream()

  // 关注用户
  Future<void> followUser(String userId)

  // 取消关注
  Future<void> unfollowUser(String userId)

  // 加好友
  Future<void> addFriend(String userId)

  // 发送礼物
  Future<void> sendGift(String userId, String giftId)

  // 记录用户行为（浏览、点赞、评论、收藏、分享）
  Future<void> recordUserAction(String contentId, UserAction action)

  // 获取用户活跃度积分
  Future<int> getUserActivityPoints()

  // 获取解锁的奖励
  Future<List<Reward>> getUnlockedRewards()

  // 获取打卡进度
  Future<CheckInProgress> getCheckInProgress()

  // 打卡
  Future<void> checkIn()

  // 获取打卡榜
  Future<List<UserRanking>> getCheckInLeaderboard()
}
```

#### 数据结构
```dart
class RecommendedItem {
  final String id;
  final String imageUrl;
  final String authorName;
  final String description;
  final int likeCount;
  final int commentCount;
  final int shareCount;
  final bool isLiked;
  final bool isFollowed;
  final bool isFriend;
  final List<String> tags;
}

enum UserAction {
  view,      // 浏览
  like,      // 点赞
  comment,   // 评论
  favorite,  // 收藏
  share      // 分享
}

class Reward {
  final String id;
  final String name;
  final String iconUrl;
  final RewardType type;  // title, sticker, emoji, skin, avatar
  final int requiredPoints;
  final bool isUnlocked;
}

class CheckInProgress {
  final int currentStreak;    // 当前连续天数
  final int totalDays;        // 总打卡天数
  final int requiredStreak;   // 需要连续天数
  final List<DateTime> checkInDates;
  final bool canClaimReward;
}
```

#### UI集成点
- 推荐页面：上下滑动卡片列表
- 用户资料卡：显示作者信息和互动按钮
- 礼物选择器：选择发送的礼物
- 积分显示：活跃度积分和奖励状态
- 打卡界面：进度条和打卡按钮
- 排行榜：TOP用户特别展示


### 7. 激励文字服务 (MotivationalQuotesService)

#### 功能描述
管理扔大便激励文字的词库，提供随机文字展示功能

#### 功能模块与API/数据库依赖

| 功能 | 是否需要API | 数据库表 | 存储过程 |
|------|------------|----------|----------|
| 获取随机激励文字 | ✅ 需要 | `motivational_quotes` | `get_random_motivational_quote` |
| 获取今日推荐文字 | ✅ 需要 | `motivational_quotes`, `user_quote_usage` | `get_today_recommendation` |
| 记录文字使用情况 | ✅ 需要 | `user_quote_usage` | `record_quote_usage` |
| 获取所有可用文字 | ✅ 需要 | `motivational_quotes` | - |
| 按分类获取文字 | ✅ 需要 | `motivational_quotes`, `quote_categories` | - |
| 添加/修改/删除文字 | ✅ 需要(管理员) | `motivational_quotes` | - |

> **数据库依赖**: `激励文字数据库.sql`

---

### 激励文字服务API调用详解

#### API接口列表

| 接口 | 方法 | 功能 |
|------|------|------|
| `/api/quotes/random` | GET | 获取随机激励文字 |
| `/api/quotes/today` | GET | 获取今日推荐文字（避免重复） |
| `/api/quotes/usage` | POST | 记录文字使用情况和评分 |
| `/api/quotes` | GET | 获取所有激励文字（分页） |
| `/api/quotes/categories` | GET | 获取文字分类列表 |
| `/api/quotes/category/:name` | GET | 按分类获取文字 |
| `/api/quotes` | POST | 添加新的激励文字（管理员） |
| `/api/quotes/:id` | PUT | 更新激励文字（管理员） |
| `/api/quotes/:id` | DELETE | 删除激励文字（管理员） |

#### 调用流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│  获取随机激励文字流程                                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 前端需要展示激励文字（如扔便便后、登录动画中）                          │
│           ↓                                                         │
│  2. 调用 getRandomQuote() → GET /api/quotes/random                  │
│           ↓                                                         │
│  3. 数据库执行 get_random_motivational_quote() 存储过程               │
│           ↓                                                         │
│  4. 返回随机激励文字数据                                               │
│           ↓                                                         │
│  5. 前端展示文字，同时记录使用情况                                       │
│           ↓                                                         │
│  6. 调用 recordUsage() → POST /api/quotes/usage                     │
│           ↓                                                         │
│  7. 数据库更新使用统计，用于优化推荐                                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  今日推荐文字流程（智能避重）                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 前端请求今日推荐文字                                                │
│           ↓                                                         │
│  2. 调用 getTodayQuote() → GET /api/quotes/today?user_id=xxx        │
│           ↓                                                         │
│  3. 数据库执行 get_today_recommendation(userId)                      │
│           ↓                                                         │
│  4. 查找今日未展示过的高效文字                                           │
│     优先级：效果评分高 + 使用次数少                                       │
│           ↓                                                         │
│  5. 返回个性化推荐文字                                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 详细API调用说明

**1. 获取随机激励文字**
```dart
Future<MotivationalQuote> getRandomQuote() async {
  final response = await api.get('/api/quotes/random');
  // 数据库执行: CALL get_random_motivational_quote()
  return MotivationalQuote.fromJson(response.data['data']);
}
```

**2. 获取今日推荐文字（避免重复）**
```dart
Future<MotivationalQuote> getTodayQuote(String userId) async {
  final response = await api.get('/api/quotes/today', queryParameters: {
    'user_id': userId,
  });
  // 数据库执行: CALL get_today_recommendation(userId)
  // 算法: 优先展示效果评分高、使用次数少、今日未展示的文字
  return MotivationalQuote.fromJson(response.data['data']);
}
```

**3. 记录文字使用情况**
```dart
Future<void> recordUsage(String userId, String quoteId, {int? rating}) async {
  await api.post('/api/quotes/usage', data: {
    'user_id': userId,
    'quote_id': quoteId,
    'rating': rating,  // 可选：用户评分1-5
  });
  // 数据库执行: CALL record_quote_usage(userId, quoteId, rating)
  // 更新 usage_count 用于优化推荐算法
}
```

**4. 按分类获取文字**
```dart
Future<List<MotivationalQuote>> getQuotesByCategory(String category) async {
  final response = await api.get('/api/quotes/category/$category');
  return (response.data['data'] as List)
      .map((e) => MotivationalQuote.fromJson(e))
      .toList();
}
```

**API响应示例 - 随机文字**
```json
{
  "success": true,
  "data": {
    "id": "quote_001",
    "text": "在最好的青春里，在格子间里激励自己开出最美的花！",
    "category": "motivation",
    "category_display": "激励类",
    "author": "系统",
    "usage_count": 128,
    "effectiveness_score": 0.85,
    "tags": ["青春", "奋斗", "激励"]
  }
}
```

**API响应示例 - 分类列表**
```json
{
  "success": true,
  "data": [
    { "name": "motivation", "display_name": "激励类", "color": "#4CAF50", "icon": "trending_up", "count": 5 },
    { "name": "humor", "display_name": "幽默类", "color": "#FF9800", "icon": "sentiment_satisfied", "count": 4 },
    { "name": "inspirational", "display_name": "鼓舞类", "color": "#2196F3", "icon": "lightbulb", "count": 4 },
    { "name": "sarcastic", "display_name": "讽刺类", "color": "#F44336", "icon": "mood_bad", "count": 2 }
  ]
}
```

#### 推荐算法说明

```sql
-- 今日推荐优先级：
-- 1. 排除今日已展示过的文字
-- 2. 按效果评分(effectiveness_score)降序
-- 3. 按使用次数(usage_count)升序（低使用优先）

SELECT mq.* FROM motivational_quotes mq
LEFT JOIN user_quote_usage uqu 
  ON mq.id = uqu.quote_id 
  AND uqu.user_id = ? 
  AND DATE(uqu.used_at) = CURDATE()
WHERE mq.is_active = true AND uqu.id IS NULL
ORDER BY mq.effectiveness_score DESC, mq.usage_count ASC
LIMIT 1;
```

---

#### 核心方法
```dart
class MotivationalQuotesService {
  // 获取随机激励文字
  Future<String> getRandomQuote()

  // 获取所有可用文字
  Future<List<String>> getAllQuotes()

  // 添加新的激励文字（管理员功能）
  Future<void> addQuote(String quote)

  // 删除激励文字（管理员功能）
  Future<void> removeQuote(String quoteId)

  // 更新激励文字（管理员功能）
  Future<void> updateQuote(String quoteId, String newQuote)

  // 获取今日推荐文字（基于用户行为）
  Future<String> getTodayQuote()
}
```

#### 词库数据结构
```dart
class MotivationalQuote {
  final String id;
  final String text;
  final DateTime createdAt;
  final String author; // 可选
  final int usageCount; // 使用次数
  final double effectiveness; // 效果评分
  final List<String> tags; // 标签分类
}

enum QuoteCategory {
  motivation,    // 激励类
  humor,        // 幽默类
  inspirational, // 鼓舞类
  sarcastic     // 讽刺类
}
```

#### 词库内容示例
```dart
const List<String> defaultQuotes = [
  "在最好的青春里，在格子间里激励自己开出最美的花！",
  "工作虽苦，但扔大便的快乐谁懂？",
  "996的你，值得一个大大的便便！",
  "在格子间里，做一个会扔便便的自由灵魂",
  "青春不只是奋斗，还有扔大便的快感",
  "工作压力大？扔个便便释放一下",
  "在办公室的角落，藏着你的小确幸",
  "不是加班辛苦，是没扔便便的遗憾",
  "扔出你的不满，迎接更好的明天",
  "便便虽小，快乐无穷",
  "在格子间里，找到属于你的释放方式",
  "工作再累，也要记得扔便便的乐趣",
  "青春奋斗路，便便相伴",
  "释放压力，从扔便便开始",
  "在办公室里，做一个快乐的扔便便者"
];
```

#### 随机选择算法
```dart
class QuoteSelector {
  // 基于权重的随机选择
  String selectWeightedRandom(List<MotivationalQuote> quotes) {
    // 根据使用频率和效果评分计算权重
    // 低频高效果的文字优先展示
  }

  // 避免重复的智能随机
  String selectSmartRandom(List<MotivationalQuote> quotes, List<String> recentQuotes) {
    // 避免短时间内重复相同的文字
    // 确保用户看到不同的激励内容
  }

  // 基于用户行为的个性化选择
  String selectPersonalized(List<MotivationalQuote> quotes, UserBehavior behavior) {
    // 根据用户的活跃度、喜好等选择合适的文字
  }
}
```

#### 数据库设计
```sql
-- 激励文字表
CREATE TABLE motivational_quotes (
  id VARCHAR(36) PRIMARY KEY,
  text TEXT NOT NULL,
  category VARCHAR(20),
  author VARCHAR(100),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  usage_count INT DEFAULT 0,
  effectiveness_score DECIMAL(3,2) DEFAULT 0.0,
  is_active BOOLEAN DEFAULT true,
  tags JSON
);

-- 用户文字使用记录表
CREATE TABLE user_quote_usage (
  id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36),
  quote_id VARCHAR(36),
  used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  user_rating INT, -- 用户对文字的评分
  FOREIGN KEY (quote_id) REFERENCES motivational_quotes(id)
);
```

### 9. 通知服务 (NotificationService)

#### 功能描述
处理推送通知、活动提醒、以及邮箱/系统内登录通知发送策略分析

#### 功能模块与API/数据库依赖

| 功能 | 是否需要API | 数据库表 | 存储过程 |
|------|------------|----------|----------|
| 获取通知列表 | ✅ 需要 | `notifications` | `api_notification_list` |
| 标记通知已读 | ✅ 需要 | `notifications` | `api_notification_mark_read` |
| 获取未读数量 | ✅ 需要 | `notifications` | `api_notification_unread_count` |
| 发送邮箱验证码 | ✅ 需要 | `email_verification_codes`, `email_send_logs` | `api_email_send_code` |
| 验证邮箱验证码 | ✅ 需要 | `email_verification_codes` | `api_email_verify_code` |
| 创建安全事件 | ✅ 需要 | `security_events`, `notifications` | `api_security_create_event` |
| 获取安全事件历史 | ✅ 需要 | `security_events` | `api_security_get_events` |
| 获取/更新通知设置 | ✅ 需要 | `user_notification_settings` | `api_notification_get_settings` |
| 发送本地通知 | ❌ 本地 | - | - |
| 请求通知权限 | ❌ 本地 | - | - |

> **数据库依赖**: `通知服务数据库初始化.sql`

---

### 通知服务API调用详解

#### API接口列表

| 接口 | 方法 | 功能 |
|------|------|------|
| `/api/notifications` | GET | 获取通知列表 |
| `/api/notifications` | POST | 创建新通知 |
| `/api/notifications/:id/read` | PUT | 标记单条通知已读 |
| `/api/notifications/read-all` | PUT | 标记所有通知已读 |
| `/api/notifications/unread-count` | GET | 获取未读通知数量 |
| `/api/notifications/settings` | GET | 获取通知设置 |
| `/api/notifications/settings` | PUT | 更新通知设置 |
| `/api/email/send-code` | POST | 发送邮箱验证码 |
| `/api/email/verify-code` | POST | 验证邮箱验证码 |
| `/api/security/event` | POST | 创建安全事件（触发通知） |
| `/api/security/events` | GET | 获取安全事件历史 |

#### 调用流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│  邮箱验证码发送流程                                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 用户输入邮箱，点击获取验证码                                        │
│           ↓                                                         │
│  2. 调用 sendLoginEmailCode() → POST /api/email/send-code           │
│           ↓                                                         │
│  3. 数据库执行 api_email_send_code()                                 │
│           ↓                                                         │
│  4. 检查发送频率（1分钟内只能发送1次）                                   │
│           ↓                                                         │
│  5. 生成6位验证码，存入数据库（15分钟有效）                              │
│           ↓                                                         │
│  6. 调用邮件服务发送验证码邮件                                          │
│           ↓                                                         │
│  7. 用户收到邮件，输入验证码                                            │
│           ↓                                                         │
│  8. 调用 POST /api/email/verify-code 验证                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  安全事件通知流程（新设备登录）                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 检测到用户在新设备登录                                              │
│           ↓                                                         │
│  2. 调用 POST /api/security/event 创建安全事件                        │
│           ↓                                                         │
│  3. 数据库执行 api_security_create_event()                           │
│           ↓                                                         │
│  4. 自动创建APP内通知（高优先级）                                        │
│           ↓                                                         │
│  5. 根据用户设置，发送邮件通知（双通道）                                  │
│           ↓                                                         │
│  6. 前端收到推送，展示安全提醒                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 详细API调用说明

**1. 发送邮箱验证码**
```dart
Future<SendCodeResult> sendLoginEmailCode(String email) async {
  final response = await api.post('/api/email/send-code', data: {
    'email': email,
    'code_type': 'login',  // login, register, reset_password, verify_email
  });
  // 数据库执行: CALL api_email_send_code(email, type, ip, ua, @code, @success, @message)
  // 限制: 同一邮箱1分钟内只能发送1次
  // 有效期: 15分钟
  return SendCodeResult.fromJson(response.data);
}
```

**2. 验证邮箱验证码**
```dart
Future<VerifyResult> verifyEmailCode(String email, String code, String type) async {
  final response = await api.post('/api/email/verify-code', data: {
    'email': email,
    'code': code,
    'code_type': type,
  });
  // 数据库执行: CALL api_email_verify_code(email, code, type, @success, @message)
  return VerifyResult.fromJson(response.data);
}
```

**3. 获取通知列表**
```dart
Future<List<AppNotification>> getNotifications({String? type, bool unreadOnly = false}) async {
  final response = await api.get('/api/notifications', queryParameters: {
    'user_id': currentUserId,
    'type': type,  // security, activity, social, reward, system
    'unread_only': unreadOnly,
    'page': 1,
    'page_size': 20,
  });
  return (response.data['data'] as List).map((e) => AppNotification.fromJson(e)).toList();
}
```

**4. 创建安全事件（触发双通道通知）**
```dart
Future<void> sendSecurityAlert(String userId, String eventType, Map<String, dynamic> deviceInfo) async {
  await api.post('/api/security/event', data: {
    'user_id': userId,
    'event_type': eventType,  // new_device_login, abnormal_location, password_change
    'device_info': deviceInfo,
    'ip_address': await getClientIP(),
    'location': await getLocation(),
    'risk_level': 'medium',  // low, medium, high, critical
  });
  // 数据库自动创建APP内通知 + 发送邮件通知
}
```

**API响应示例 - 发送验证码**
```json
{
  "success": true,
  "message": "验证码已发送",
  "expires_in": 900
}
```

**API响应示例 - 通知列表**
```json
{
  "success": true,
  "data": [
    {
      "id": "notif_001",
      "title": "新设备登录提醒",
      "body": "您的账号在iPhone 15上登录，位置：杭州。如非本人操作，请立即修改密码。",
      "notification_type": "security",
      "priority": "high",
      "is_read": false,
      "created_at": "2026-01-27T10:30:00Z",
      "data": { "event_id": "evt_001", "event_type": "new_device_login" }
    }
  ],
  "unread_count": 3
}
```

**API响应示例 - 未读数量**
```json
{
  "success": true,
  "data": {
    "total_unread": 5,
    "security_unread": 1,
    "activity_unread": 2,
    "social_unread": 1,
    "reward_unread": 1
  }
}
```

---

#### 邮箱登陆通知发送场景分析

对于用户通过邮箱登录的场景，通知渠道的选择需结合用户操作环境与安全需求：

1. **邮箱验证码登录/注册**  
   - **发送方式：邮箱发送**  
     用于用户初次注册、忘记密码、或邮箱验证等典型安全验证场景，验证码和身份确认信息必须通过用户实际填写的邮箱发送。这确保只有邮箱账号拥有者能够收到并使用验证码，保障登录安全。
   - **流程举例**：  
     1. 用户输入邮箱 → 请求验证码  
     2. 系统通过邮件服务发送包含验证码/登录链接的邮件到该邮箱  
     3. 用户查收邮箱输入验证码完成身份验证

2. **APP内消息登录提醒（安全双通道）**  
   - **发送方式：APP系统消息/推送通知**  
     当检测到用户在新的设备或异常地域通过邮箱登录时，除了邮件通知外，还推荐通过App系统内消息或推送通知提醒用户，增强安全感。例如：  
     - “您的账号于XX设备于XX时间通过邮箱登录，如非本人操作请及时处理”
   - **适用场景**：  
     - 已登录用户在其他终端用邮箱登录，需要额外安全通知  
     - 账号存在异地/异常登录行为

3. **活动消息/推广信息**  
   - **发送方式：可选，优先APP系统内消息**  
     非登录相关的运营、活动提醒，推荐优先使用APP内系统消息和推送，用户可直接在APP内查看与处理。仅在用户长时间未活跃或未安装App时考虑邮件通知。

#### 通知发送通道选择表

| 场景                  | 是否用邮箱发送 | 是否用APP系统消息/推送发送 | 备注                         |
|----------------------|:-------------:|:--------------------------:|------------------------------|
| 登录验证码            |      ✅        |             ❌             | 仅邮箱发送                   |
| 新设备/异地登录提醒   |      ✅        |             ✅             | 两种渠道均建议，增强安全      |
| 活动/公告/运营信息    |      ❌        |             ✅             | 优先系统消息，必要时用邮箱    |

#### 核心方法
```dart
class NotificationService {
  // 请求消息推送权限
  Future<bool> requestPermission();

  // 发送本地系统通知（APP端）
  Future<void> showLocalNotification(String title, String body, Map<String, dynamic> data);

  // 发送邮箱验证码（邮箱端，常用于登录/注册/找回密码等）
  Future<void> sendLoginEmailCode(String email);

  // 监听推送通知
  Stream<RemoteMessage> onMessage();

  // 处理后台消息（如收到推送时的回调处理）
  Future<void> handleBackgroundMessage(RemoteMessage message);

  // 标记通知为已读
  Future<void> markAsRead(String notificationId);

  // 获取通知历史
  Future<List<AppNotification>> getNotifications();

  // 发送登录/安全提醒邮件
  Future<void> sendSecurityAlertEmail(String email, String deviceInfo, DateTime loginTime);

  // 发送系统内安全通知
  Future<void> sendAppSecurityAlert(String userId, String message, Map<String, dynamic> meta);
}
```

> **结论**：  
> - 邮箱验证码等必须通过邮箱渠道发送；  
> - 登录安全提醒建议双通道（邮箱+APP系统消息/推送）；  
> - 一般消息优先APP系统内，必要时可发邮件辅助通知。


## 服务层架构

### 数据同步策略

#### 1. Firebase 优先数据（实时同步）
- **用户状态数据**：在线状态、位置信息、即时消息
- **游戏实时数据**：地图更新、大便塔变化、用户互动
- **缓存数据**：离线时本地存储，恢复后自动同步

#### 2. API 服务数据（业务逻辑）
- **复杂查询**：多表关联查询、数据聚合统计
- **文件处理**：图像审核、压缩、格式转换
- **业务计算**：积分计算、排行榜生成、推荐算法

#### 3. 混合同步机制
```typescript
// Firebase实时数据
const realtimeData = {
  userPresence: firebase.firestore().collection('users').doc(userId),
  mapUpdates: firebase.database().ref('map_updates'),
  liveInteractions: firebase.firestore().collection('interactions')
};

// API业务数据
const apiData = {
  userStats: axios.get('/api/users/stats'),
  recommendations: axios.get('/api/recommendations'),
  achievements: axios.get('/api/achievements')
};
```

### 依赖注入
```dart
class ServiceLocator {
  static final ServiceLocator _instance = ServiceLocator._internal();

  // Firebase服务
  late FirebaseAuth auth;
  late FirebaseFirestore firestore;
  late FirebaseDatabase database;
  late FirebaseStorage storage;

  // API服务
  late Dio apiClient;

  // 业务服务
  late AuthService authService;
  late LoginDemoService loginDemoService;
  late MapService mapService;
  late SwipeService swipeService;
  late DrawingService drawingService;
  late RecommendationService recommendationService;
  late PointsService pointsService;
  late MotivationalQuotesService motivationalQuotesService;
  late NotificationService notificationService;

  factory ServiceLocator() {
    return _instance;
  }

  ServiceLocator._internal() {
    _initializeFirebase();
    _initializeApiClient();
    _initializeServices();
  }

  void _initializeFirebase() {
    auth = FirebaseAuth.instance;
    firestore = FirebaseFirestore.instance;
    database = FirebaseDatabase.instance;
    storage = FirebaseStorage.instance;
  }

  void _initializeApiClient() {
    apiClient = Dio(BaseOptions(
      baseUrl: 'https://api.yourapp.com',
      connectTimeout: 5000,
      receiveTimeout: 3000,
    ));
  }

  void _initializeServices() {
    authService = AuthService(auth, apiClient);
    loginDemoService = LoginDemoService(motivationalQuotesService);
    mapService = MapService(database, firestore);
    swipeService = SwipeService(firestore, apiClient);
    drawingService = DrawingService(storage, apiClient);
    recommendationService = RecommendationService(firestore, apiClient);
    pointsService = PointsService(firestore, apiClient);
    motivationalQuotesService = MotivationalQuotesService(firestore, apiClient);
    notificationService = NotificationService();
  }
}
```

## 错误处理和状态管理

### 统一错误处理
```dart
class AppError {
  final String code;
  final String message;
  final dynamic data;

  AppError(this.code, this.message, [this.data]);
}

enum ErrorCode {
  networkError,
  authError,
  validationError,
  serverError,
  permissionDenied,
  contentNotFound
}
```

### 状态管理集成
每个服务都应该与状态管理器（Provider/Riverpod）集成，确保UI能够响应数据变化。

## 性能优化

### 混合缓存策略

#### 1. Firebase 原生缓存
- **Firestore缓存**：自动缓存查询结果，支持离线访问
- **Storage缓存**：智能缓存下载的文件和图片
- **本地持久化**：网络恢复后自动同步变更

#### 2. API 数据缓存
- **HTTP缓存**：使用ETag和Last-Modified头
- **内存缓存**：热点数据在内存中缓存
- **磁盘缓存**：大型数据文件本地存储

#### 3. 多层缓存架构
```typescript
// Firebase缓存层
const firebaseCache = {
  realtimeData: new Map(), // 实时数据缓存
  offlineQueue: [],       // 离线操作队列
  syncStatus: 'online'    // 同步状态
};

// API缓存层
const apiCache = {
  memoryCache: new Map(), // 内存缓存
  diskCache: new Map(),   // 磁盘缓存
  cachePolicy: 'LRU'      // 缓存策略
};

// 智能缓存管理器
class CacheManager {
  get(key: string) {
    // 先查Firebase缓存
    if (firebaseCache.realtimeData.has(key)) {
      return firebaseCache.realtimeData.get(key);
    }
    // 再查API缓存
    if (apiCache.memoryCache.has(key)) {
      return apiCache.memoryCache.get(key);
    }
    // 最后查磁盘缓存
    return apiCache.diskCache.get(key);
  }
}
```

### 内存管理
- 及时释放不需要的资源
- 图像内存优化
- 动画性能监控

这个前端服务设计完全基于README.md的需求，涵盖了所有核心功能模块，每个服务都提供了完整的方法接口和数据结构定义，可以直接用于Flutter开发实现。